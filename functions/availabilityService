import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {DynamoDBDocumentClient,ScanCommand,} from "@aws-sdk/lib-dynamodb";
import {InvokeCommand, LambdaClient} from "@aws-sdk/client-lambda";

const lambdaClient = new LambdaClient({});
const client = new DynamoDBClient({});
const dynamo = DynamoDBDocumentClient.from(client);
const tableName = "shows";

export const handler = async (event, context) => {
    let body;
    let statusCode = 200;
    const headers = {
        "Content-Type": "application/json",
    };

    try {
        body = await dynamo.send(
            new ScanCommand({
                TableName: tableName,
                FilterExpression: "contains(#title, :title)",
                ExpressionAttributeNames: {
                    "#title": "title", // Assuming 'title' is your attribute name
                },
                ExpressionAttributeValues: {
                    ":title": event.pathParameters.title,
                },
            })
        );
        body = body.Items;
        console.log("requested data from db")
        if(body.Items > 0){

            // If entries are found for the title, return them with 200 status code
            return {
                statusCode: 200,
                body: JSON.stringify(body.Item)
            };
        } else {
            // If no entries are found, invoke the second Lambda function and wait for the response
            const payloadBytes = new TextEncoder().encode(JSON.stringify({
                "title": event.pathParameters.title,
                "country": event.queryStringParameters.country,
                "type": event.queryStringParameters.type
            }));
            const invokeParams = {
                FunctionName: 'getavailability',
                InvocationType: 'RequestResponse',
                Payload: payloadBytes
            };
            const invokeCommand = new InvokeCommand(invokeParams);
            const invokeResponse = await lambdaClient.send(invokeCommand);

            if (invokeResponse.StatusCode === 200) {
                // If the invocation was successful, handle the response from the second Lambda function
                const responsePayload = JSON.parse(new TextDecoder().decode(invokeResponse.Payload));

                // Process the responsePayload and return the appropriate response
                return {
                    statusCode: 200,
                    body: JSON.stringify(responsePayload)
                };
            } else {
                // If the invocation failed, return an error response
                return {
                    statusCode: invokeResponse.StatusCode,
                    body: JSON.stringify({ message: 'Invocation error' })
                };
            }

        }
    } catch (err) {
        statusCode = 400;
        body = err.message;
    } finally {
        body = JSON.stringify(body);
    }

    return {
        statusCode,
        body,
        headers,
    };
};
